"""This file is used for https://github.com/ultralytics/yolov3 """

import os
import json
import argparse
import shutil
from tqdm import tqdm


class Convertor():

    def get_classes(self, path):
        """The path to the meta file generated by supervise.ly"""
        classes = []
        data_folder_name = path.split('/')[-1]
        meta_path = os.path.join(path, 'meta.json')
        with open(meta_path, 'rb') as f:
            contents = json.load(f)
        for content in contents['classes']:
            classes.append(content['title'])

        return classes, data_folder_name

    def move_images(self, new_dir, org_dir, image_mask, data_folder_name):
        for img_name in tqdm(image_mask):
            img_name = img_name.replace('.jpg.json', '.jpg')
            img_path = os.path.join(org_dir, img_name)
            new_img_path = os.path.join(new_dir, data_folder_name + '_' + img_name)
            shutil.copy(img_path, new_img_path)

    def make_dirs(self, new_data_dir, mode):

        if mode == 'train':
            img_dir = os.path.join(new_data_dir, 'images', mode)
            os.makedirs(img_dir, exist_ok=True)

            label_dir = os.path.join(new_data_dir, 'labels', mode)
            os.makedirs(label_dir, exist_ok=True)

        elif mode == 'val':
            img_dir = os.path.join(new_data_dir, 'images', mode)
            os.makedirs(img_dir, exist_ok=True)

            label_dir = os.path.join(new_data_dir, 'labels', mode)
            os.makedirs(label_dir, exist_ok=True)

        return img_dir, label_dir

    def xyxy2xyhw(self, coordinates, img_size):
        img_h, img_w = img_size
        img_h, img_w = float(img_h), float(img_w)
        x1, y1 = coordinates[0]  # Top-left corner
        x2, y2 = coordinates[1]  # Bottom-right corner

        x_c = (x1 + x2) / 2
        y_c = (y1 + y2) / 2
        box_w = x2 - x1
        box_h = y2 - y1

        # Rescale box w.r.t img size
        x_c /= img_w
        y_c /= img_h
        box_w /= img_w
        box_h /= img_h

        box_coor = [x_c, y_c, box_w, box_h]
        box_coor = [('%.6f' % i) for i in box_coor]

        return box_coor

    def write_to_file(self, file_path, boxes_info):
        """ Write the content to file"""

        for i in range(len(boxes_info)):
            temp = ''
            for j in boxes_info[i]:
                temp += str(j) + ' '

            with open(file_path, 'a') as f_obj:
                f_obj.write(temp.strip(' ') + '\n')

    def add_extra_files(self, root_dir, classes):
        def reformat_path(path):
            if path.split('/')[0] == '..':
                path = path.replace('..', '.')
            return path

        dataset_name = root_dir.split('/')[-1]

        # write _train.txt
        train_txt_path = os.path.join(root_dir, f"{dataset_name}_train.txt")
        train_imgs_dir = os.path.join(root_dir, 'images/train')
        train_imgs = os.listdir(train_imgs_dir)
        with open(train_txt_path, 'a') as f1:
            for train_img in train_imgs:
                f1.write(os.path.join('./images/train', train_img) + '\n')

        # write _val.txt
        val_txt_path = os.path.join(root_dir, f"{dataset_name}_val.txt")
        val_imgs_dir = os.path.join(root_dir, 'images/val')
        val_imgs = os.listdir(val_imgs_dir)
        with open(val_txt_path, 'a') as f2:
            for val_img in val_imgs:
                f2.write(os.path.join('./images/val', val_img) + '\n')

        # write .names
        names_path = os.path.join(root_dir, f"{dataset_name}.names")
        with open(names_path, 'a') as f3:
            for cls_name in classes:
                f3.write(cls_name + '\n')

        # write .data
        datafile_path = os.path.join(root_dir, f"{dataset_name}.data")
        with open(datafile_path, 'a') as f4:
            f4.write('classes=' + str(len(classes)) + '\n')
            f4.write('train=' + reformat_path(train_txt_path) + '\n')
            f4.write('valid=' + reformat_path(val_txt_path) + '\n')
            f4.write('names=' + reformat_path(names_path))

    def get_num_of_data(self, org_dir):
        _, data_folder_name = self.get_classes(org_dir)
        org_ann_dir = os.path.join(org_dir, data_folder_name, 'ann')
        ann_files = os.listdir(org_ann_dir)
        img_mask = []  # store the name of image with objects
        for ann in tqdm(ann_files):
            if ann.endswith('.json'):
                ann_path = os.path.join(org_ann_dir, ann)
                with open(ann_path, 'rb') as f:
                    anns_info = json.load(f)
                objects = anns_info['objects']
                num_objs = len(objects)
                if num_objs != 0:
                    img_mask.append(ann)
        return len(img_mask)

    def convert(self, org_dir, output_dir, mode):
        classes, data_folder_name = self.get_classes(org_dir)
        org_ann_dir = os.path.join(org_dir, data_folder_name, 'ann')
        org_img_dir = os.path.join(org_dir, data_folder_name, 'img')

        ann_files = os.listdir(org_ann_dir)
        img_mask = []  # store the name of image with objects

        if mode == 'train':  # training data
            output_img_dir, output_label_dir = self.make_dirs(output_dir, mode)
        else:  # val data
            output_img_dir, output_label_dir = self.make_dirs(output_dir, mode)

        for ann in tqdm(ann_files):
            if ann.endswith('.json'):
                ann_path = os.path.join(org_ann_dir, ann)
                with open(ann_path, 'rb') as f:
                    anns_info = json.load(f)

                objects = anns_info['objects']
                num_objs = len(objects)
                if num_objs != 0:
                    img_mask.append(ann)
                    img_h, img_w = anns_info['size']['height'], anns_info['size']['width']  # (h, w)
                    boxes_info = []
                    for idx in range(num_objs):
                        class_name = objects[idx]['classTitle']
                        coordinates = objects[idx]['points']['exterior']
                        box_info = self.xyxy2xyhw(coordinates, [img_h, img_w])
                        class_idx = classes.index(class_name)
                        box_info.insert(0, class_idx)
                        boxes_info.append(box_info)

                    output_path = os.path.join(output_label_dir, data_folder_name + '_' + ann.replace('.jpg.json', '.txt'))
                    self.write_to_file(output_path, boxes_info)

        self.move_images(output_img_dir, org_img_dir, img_mask, data_folder_name)


if __name__ == '__main__':
    parse = argparse.ArgumentParser()
    parse.add_argument('--org_dir', type=str, default='../data/hands6/P01_03',
                       help='the root path to the data needed to be converted')
    parse.add_argument('--output_dir', type=str, default='../data/hands',
                       help='the root path where store the converted labels and images')
    parse.add_argument('--mode', type=str, default='val', help='training data or val data')
    parse.add_argument('--write_flag', type=bool, default=True, help='if write the data configuration files')
    opt = parse.parse_args()

    convertor = Convertor()
    convertor.convert(
        opt.org_dir,
        opt.output_dir,
        opt.mode,
    )

    if opt.write_flag:
        modes = ['train', 'val']
        classes, _ = convertor.get_classes(opt.org_dir)
        try:
            convertor.add_extra_files(opt.output_dir, classes)
        except FileNotFoundError:
            modes.remove(opt.mode)
            convertor.make_dirs(opt.output_dir, modes[-1])
            convertor.add_extra_files(opt.output_dir, classes)
